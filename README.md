Αναστασία Ορφανουδάκη 1115202100129
Ενασχόληση με greedy search algorithm

Για την υλοποίηση του αλγορίθμου Greedy Search χειριζόμαστε τρεια σύνολα. Ένα σύνολο ( vector<Node*> ) για την λειτουργία της λίστας L, ένα σύνολο ( vetcor<Node*> ) για την αποθήκευση των κόμβων που θα επιστραφούν ως αποτέλεσμα , εξού και το όνα του συνόλου ως result και τέλος ένα σύνολο ( unordered_set<Node*> ) , για την αποθήκευση των κόμβων που έχουμε απισκεφτεί , V. Ο λόγος που επιλέξαμε το σύνολο V να είναι unordersd_set είναι για να αποφύγουμε την αποθήκευη duplicate κόμων.
Αχρικά διατρέχουμε όλους τους κόμβους της λίστας L και για κάθε έναν αν δεν τον έχουμε επιστεφτεί τότε υπολογίζουμε την ευκλείδια απόστασή του από το σημείο-ερώτηση με σκοπό να βρούμε το σημείο με τη μικρότερη απόσταση από το σημείο-ερώτηση, όπου αποκαλούμε p_star. 
Αν έχουμε βρει το σημείο p_star τότε το προσθέτουμε στη λίστα V και στο σύνολο result και προσθέτουμε τους εξρχόμενους γείτονες του σημείου p_star (αν δεν τους έχουμε ήδη επισκεφθεί) στη λίστα L.
Τέλος, άμα το μέγεθος της λίστα L υπερβεί το μέγεθος list_size που παίρνει ως παράμετρο η συνάρτηση μας τότε 
καλούμε την nth_element(), η οποία ταξινομεί το σύνολο ( L ) , με βάση την συνάρτηση που της παιρνάμε ( calculate_distance(a, x_q) < calculate_distance(b, x_q) )  μόνο μέχρι το nth στοιχείο ( list_size ). Οπότε στη συνέχεια κρατάμε μόνο τα πρώτα list_size στοιχεία στη λίστα L ( L.resize(list_size) ). 



Ιουλία Οσανττσίβ 1115202100130
Ενασχόληση με Vamana Indexing algorithm

Σχεδιαστικές επιλογές:
Ο σχεδιασμός της VamanaIndexingAlgorithm έγινε με πιστή ακολουθία στη δομή του ψευδοκώδικα της εκφώνησης. Ο γράφος G αρχικοποιείται με τυχαίους R γείτονες για κάθε κόμβο μέσω κλήσης αντίστοιχης συνάρτησης initializeRandomGraph η οποία εξασφαλίζει ότι οι γείτονες ενός γράφου δεν είναι διπλότυποι και δεν ταυτίζονται με τον εαυτό του.
Στη συνέχεια βρίσκουμε τον ενδιάμεσο s, ο οποίος είναι το πιο κεντρικό σημείο, μέσω κλήσης της approximateMedoid.Μετά από προσπάθεια εύρεσης του medoid με εξέταση κάθε κόμβου, καταλήγαμε σε ακρίβεια, αλλά η διαδικασία ήταν αρκετα χρονοβόρα με πολυπλοκότητα χρόνου Ο(n^2). Γι'αυτό καταλήξαμε στη παρακάτω λογική, η οποία στηρίζεται στο k-means clustering https://en.wikipedia.org/wiki/K-means_clustering, περιορίζοντας αρκετά την αναζήτηση του medoid και έτσι βελτιώνοντας πια την πολυπλοκότητα και άρα την αποδοτικότητα.  Η approximateMedoid(nodes,k) σπάει τα nodes σε k clusters και επιλέγει το μεγαλύτερο cluster. Έπειτα υπολογίζει το centroid του μεγαλύτερου cluster το οποίο θα αποτελέσει reference point για τον medoid. Και τελικά βρίσκει τον κόμβο από το συγκεκριμένο cluster που έχει την μικρότερη απόσταση από το centroid και το ορίζει ως medoid. Συνεπώς με εύρεση του medoid μέσω centroid, αποφύγαμε το κόστος υπολογισμού απόστασης για κάθε κόμβο με κάθε γείτονά του, το οποίο αποτελούσε χρονοβόρα διαδικασία, αλλά χάνουμε πιθανόν σε ακρίβεια αφού παραβλέπουμε την αναζήτηση medoid για άλλα clusters.(Πιθανόν πρόβλημα σε clusters με ίδια μεγέθη) 
Για να πετύχουμε την επανάληξη του αλγορίθμου σε τυχαία σημεία δημιουργούμε ένα permutation vector τυπου int το οποίο περιέχει όλα τα indices των κόμβων και για να εξασφαλίζουμε την τυχαιότητα εκτελούμε ανακάτεμα δεικτών στο permutation μέσω αλγορίθμου fisher-yates https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
Στη συνέχεια παίρνοντας έναν έναν από τους ανακατεμμένους δείκτες εκτελούμε την GreedySearch(s, p, 1, L),όπου s ο κόμβος που ξεκινάμε την αναζήτηση, p ο κόμβος που θέλουμε να φτάσουμε και L το μήκος της λίστας.Μετά την κλήση λαμβάνουμε το ένα σημείο που έχει επισκεφτεί η GreedySearch(αφού k=1).
Στη συνέχεια καλούμε την RobustPrune(p, V_p, a, R) η οποία καθορίζει το πολύ R εξερχόμενους γείτονες για τον p από το σύνολο V_p με μέγιστη απόσταση a.
Στη συνέχεια προσθέτουμε αντίθετες ακμές στο γράφο από τους εξερχόμενους γείτονες, δηλαδή εισερχόμενες ακμές (p',p) για κάθε εξερχόμενη ακμή του p.
Η διαδικασία αυτή γίνεται χωρίς να ξεπερνάτε ο μέγιστος αριθμός εξερχόμενων γειτόνων, αλλιώς εφαρμόζουμε πάλι prunning για τον εξερχόμενο γείτονα, με πιθανό σύνολο εξερχόμενων γειτόνων τους γείτονές του + τον p.



Αλέξανδρος Κούτρας 1115202100073
Ενασχόληση με Robust Pruning

Για την υλοποίηση της RobustPrune, χρειαζόμαστε τη δομή Node. Προσθέτουμε τους γείτονες ενός Node που μας δίνεται ως όρισμα στους πιθανούς γείτονες του ορίσματος
και καθαρίζουμε μετά τους γείτονες, καθώς δεν εγγυάται η μέθοδος RobustPrune ότι οι παλιοί γείτονες θα παραμείνουν γείτονες μετά το πέρας της συνάρτησης. Βρίσκουμε
την απόσταση όλων των πιθανών γειτόνων από το Node που πήραμε από το όρισμα και μετά τα κατατάσσουμε με αύξουσα σειρά. Διατρέχουμε τη λίστα των πιθανών γειτόνων μέχρι
να τελειώσει η λίστα ή μέχρι να προσθέσουμε στο Node τον μέγιστο αριθμό γειτόνων που επιτρέπεται να έχει. Για κάθε πιθανό γείτονα, τον προσθέτουμε στους γείτονες και
τον αφαιρούμε από τους πιθανούς. Για κάθε έναν, ελέγχουμε αν ισχύει η συνθήκη a * d(p*, p') <= d(p, p'). Αν ισχύει, το διαγράφουμε, αν όχι, προχωράμε στο επόμενο.